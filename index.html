<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Strange Loop 2018 - Browser Testing Using Grammars and a Consensus Oracle</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

    <!-- Custom overrides -->
    <link rel="stylesheet" href="css/custom.css">

    <link rel="stylesheet" href="lib/css/darcula.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!--
        <section data-transition="none">
          <h2>Browser Testing Using Grammars and a Consensus Oracle</h2>
          <p><font color="#ffea9a">Strange Loop 2018</font></p>
          <p><font color="green">Joel Martin</font></p>
          <p>Questions at: <font color="cyan">https://sli.do</font> <font color="yellow">(Event #SL18)</font></p>
          <aside class="notes">
            <ul>
              <li>Project screen
                <ul>
                  <li>Open and full screen presentation
                  <li>Check colors/highlights on Simple PBT Example
                  <li>Open report tab
                  <li>Start full screen terminal, load tmix session
                    with history
                </ul>
              <li>Presenter screen
                <ul>
                  <li>Open new terminal connected to tmix session.
                    Populate tmix windows with history for demo
                    command lines.
                  <li>Clear out tmp/samp* files
                  <li>Start geckodriver and chromedriver in tmix
                  <li>Load/login to sli.do tab (or on phone)
                </ul>
              <li>Silence phone
          </aside>
        </section>
        -->
        <section data-transition="none">
          <h2>Browser Testing Using Grammars and a Consensus Oracle</h2>
          <p><font color="#ffea9a">Strange Loop 2018</font></p>
          <p><font color="green">Joel Martin</font></p>
          <p>Questions at: <font color="cyan">https://sli.do</font> <font color="yellow">(Event #SL18)</font></p>
          <p><i>Press 's' to show speaker notes</i></p>
          <aside class="notes">
            <ul>
              <li>Good morning everyone!
              <li>This talk is "Browser Testing Using Grammars and
                a Consensus Oracle". Hopefully that's what you were
                expecting :-)
              <li>Here is the Q&amp;A site and event code. I'm going
                to try and leave some time for questions at the end,
                but if I run out of time, I'm planning to lookup your
                questions and try and answer them on slack today or
                tomorrow. Also, please feel free to stop me during the
                so called "hallway" track if you have questions or
                feedback.
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h2>Introduction</h2>
            <div>
              <span class="fragment" data-fragment-index=1><img src="imgs/4yr.jpg" width=30% style="transform: rotate(-10deg)"></img></span>
              <span class="fragment" data-fragment-index=2><img src="imgs/5yr.jpg" width=30% style="transform: rotate(0deg)"></img></span>
              <span class="fragment" data-fragment-index=3><img src="imgs/6yr.jpg" width=30% style="transform: rotate(10deg)"></img></span>
            </div>
            <aside class="notes">
              <ul>
                <li>Okay, so quick introduction. So I asked my kids to
                  do a drawing of what I do for my job.
                <li><font color="green"> [show #1]</font>
                  This is my 4 year old daughter's take. This is her
                  in green sitting on my knee while I sit at my
                  computer.
                <li><font color="green"> [show #2]</font>
                  Here's my 5 year old son's interpretation. Here I am
                  with my headphone's on typing at my computer.
                  I especially like what look like binary on the
                  screen. Although I actually rarely have binary on
                  screen to be honest.
                <li><font color="green"> [show #3]</font>
                  Finally, my 6 year old daughter has decided that my
                  job is to sit at our coffee table and build legos
                  with my three kids.
                <li>Well, I certainly wish I could play legos with
                  them all day.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Introduction <font color="green">part 2</font></h2>
            <ul style="list-style: none">
              <li class="fragment" data-fragment-index=4>Engineer at ViaSat
              <li class="fragment" data-fragment-index=4>PhD Student at UTA
              <li class="fragment" data-fragment-index=5><a href="https://github.com/novnc/noVNC">noVNC</a>
              <li class="fragment" data-fragment-index=5><a href="https://github.com/kanaka/mal">mal / make-a-lisp</a>
            </ul>
            <aside class="notes">
              <ul>
                <li>But here's a different take...
                <li><font color="green"> [show #4]</font>
                  I'm a Principal Software Engineer at ViaSat and I am
                  also a PhD candidate at the University of Texas,
                  Arlington.
                <li><font color="green"> [show #5]</font>
                  I also started the noVNC and the make-a-lisp
                  projects.
                <li>This presentation is derived from research that
                  I'm doing for my dissertation.
                <li>The challenges and the solutions I'm going to
                  describe in this talk actually apply to a number of
                  different systems but I'm going to focus on testing of
                  browser rendering engines.
                <li>As an aside, there is a lot of material that
                  I originally planned to cover in this talk that I had
                  to drop for timing reasons. So my goal with this talk
                  is to give you the foundation pieces and to pique your
                  interest so that you'll have a new tool in your
                  testing toolbox.  <li>With that said, let's jump in.
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>The Challenges</h2>
            <ul>
              <li class="fragment" style="list-style: none"><font color="green">Test Cases</font></li>
              <li class="fragment" style="list-style: none"><font color="green">Test Oracle</font></li>
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="red">1:50</font>
                  So what's the problem we're trying to solve? Well,
                  there are some types of systems that are really hard
                  to test. And they can be hard to test in a couple of
                  ways.
                <li><font color="green"> [show #1]</font>
                  The first challenge is that it can be hard to find
                  or generate interesting test cases. And by
                  interesting all I mean is test cases that trigger
                  legitimate bugs.
                <li><font color="green"> [show #1]</font>
                  The second challenge is that some systems are hard
                  to verify. The magic box that tells you whether your
                  system under test is functioning correctly or not is
                  the Test Oracle.
                <li>
                  If we want to have fully automated testing, both the
                  generation of test cases and the test oracle will
                  need to be automated. But if the software to automate
                  those steps ends up being almost as complex as the
                  software you want to test, then you have a problem.
                  Which brings us to ...
                <!--
                <li>
                  There are some systems where determining correct
                  behavior during testing is difficult. To be more
                  precise: there exists a class of systems under test
                  for which the process of determining the correct
                  output based on a given input has a similar order of
                  complexity to the system under test itself.

                  This is the Test Oracle Problem. Our paper proposes
                  an approach to address this problem in the context
                  of web browser render testing.
                -->
              </ul>
            </aside>
          </section>
          <section>
            <h3>Browser Rendering</h3>
            <div>
              <pre class="fragment" data-fragment-index=1><code class="html" data-noescape>
&lt;html&gt;
  &lt;body style="background: #1289af"&gt;
    &lt;div style="<span class="fragment mark-current-blue" data-fragment-index=2>left: 10%; width: 20%;</span>
                font: <span class="fragment mark-current-blue" data-fragment-index=5><span class="fragment mark-current-blue" data-fragment-index=3>'Fira Sans'</span> 25px/1</span>
                      <span class="fragment mark-current-blue" data-fragment-index=4>rgba(100,100,100,0.5)</span>"&gt;
      <span class="fragment mark-current-blue" data-fragment-index=5>Pythia, Apollo, Dione.</span>
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
              </code></pre>
            </div>
            <ul>
              <li class="fragment" data-fragment-index=2>
                Element sizing and positioning
              <li class="fragment" data-fragment-index=3>
                Environment factors (Screen geometry, OS)
              <li class="fragment" data-fragment-index=4>
                Color model and alpha blending
              <li class="fragment" data-fragment-index=5>
                Font rendering (kerning, spacing)
            </ul>
            <aside class="notes">
              <ul>
                <li>Browser Rendering!
                  <font color="green">[show #1]</font> Even
                  though this web page is fairly simple compared to
                  real-world web pages, it is still non-trivial to
                  verify that a browser has rendered this page
                  correctly. There are a number of reasons for this.
                  I'll just touch on a few:
                  <ul>
                    <li><font color="green">[show #2]</font>
                      The CSS element sizing and positioning
                      standard is large and nuanced (and one of the
                      basic things we would like to test)
                    <li><font color="green">[show #3]</font>
                      environment factors: browser window geometry,
                      available OS fonts
                    <li><font color="green">[show #4]</font>
                      color model and alpha blending
                    <li><font color="green">[show #5]</font>
                      font rendering model (especially spacing
                      issues like kerning which may cause other page
                      elements to shift significantly)
                  </ul>
                <li>
                  Current solutions to browser render testing often
                  involve manual user intervention at some stage of
                  the process and use a fairly constrained test
                  environment.
                <li>So can we do better? Can we do browser testing in
                  a way that is fully automated without being narrowly
                  constrained? I think we can, so let's talk about
                  that...
              </ul>
            </aside>
          </section>
          <section>
            <h2>A Solution</h2>
            <ul>
              <li class="fragment">Property-Based Testing (PBT)</li>
              <li class="fragment">Grammar-Based Input Generators</li>
              <li class="fragment">Consensus-Based Test Oracle</li>
            </ul>
            <aside class="notes">
              There are three main components to this approach.
              <ul>
                <li><font color="green">[show #1]</font>
                  Property-based testing,
                <li><font color="green">[show #2]</font>
                  grammar-based input generators,
                <li><font color="green">[show #3]</font>
                  and a consensus-based test oracle.
              </ul>
              Let's consider each one in turn.
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Property-Based Testing (PBT)</h2>
            <ul>
              <li>QuickCheck (Claessen &amp; Hughes, 2000)
              <li>Input properties: generators
              <li>Output properties: success/failure (e.g. test Oracle)
              <li>Output property violations indicate test failure
              <li>Grow "size" until output properties violated
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="red">4:40</font>
                  Property-based testing is a testing methodology
                  that was popularized by the QuickCheck system
                  proposed by Koen Claessen and John Hughes in 2000.
                <li>In property-based testing the tester defines
                  properties or assertions about the input and output
                  values of the system under test.
                <li>Input properties define the range of valid inputs
                  to the SUT. Output properties are used by the test
                  system to validate outputs for a given set of
                  inputs. When output properties are violated the
                  corresponding inputs are considered a failing test
                  case.
                <li>A typical PBT system defines input properties in
                  terms of generator functions. Generator functions
                  can be combined to create compound generators which
                  can also be recursive.
                <li>Each input property generator function takes
                  a size value which has a generator specific
                  meaning. A single run of property-based testing
                  involves calling the generator functions with larger
                  and larger size values to stochastically generate
                  larger and larger test cases until the output
                  properties are violated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>PBT Test Shrinking</h3>
            <ul class="fragment">
              <li>Tree of generator nodes
              <li>Pick node, try small size value
              <li>Continue until "smallest" discovered
              <li>Critical for compound/recursive generators
            </ul>
            <aside class="notes">
              <ul>
                <li>Property-based testing is really effective at
                  finding bugs, but if your bug is buried in a 30MB
                  test case it's mostly not useful.
                <li>The highly recursive nature of the HTML
                  grammar means that generated test cases can easily
                  become very large.
                <li>There is a positive aspect to this in that large
                  cases can each achieve non-trivial code coverage of
                  the system under test.
                <li>The major downside to this is that large test
                  cases are not helpful to the tester in doing root
                  cause analysis.
                <li>Test shrinking can significantly reduce the size
                  of the test case while still preserving the failure
                  in the system under test. How does it work?
                <li><font color="green">[show #1]</font>
                  We can think of each test case is a tree of
                  generator nodes. Shrinking process picks a node in
                  the tree and tries a smaller size value. If
                  resulting test case is smaller then it continues
                  shrinking otherwise it backtracks. This continues
                  until a minima is reached.
                <li>Extremely important for complex compound
                  generators (e.g. recursive). Hard to overstate the
                  importance of test shrinking.
              </ul>
            </aside>
        </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre class="fragment" data-fragment-index=1><code class="clojure" data-noescape>> <span class="fragment mark-current-blue" data-fragment-index=2>(def SUT
    (fn [x] (apply + x)))</span>

> (<span class="fragment mark-current-blue" data-fragment-index=6>tc/quick-check 10</span>
    (<span class="fragment mark-current-blue" data-fragment-index=5>props/for-all</span>
      <span class="fragment mark-current-blue" data-fragment-index=3>[P (gen/vector gen/int)]</span>
      <span class="fragment mark-current-blue" data-fragment-index=4>(= (SUT P) (apply + P))</span>))
<span class="fragment mark-current-blue" data-fragment-index=7>{:result true,
 :num-tests 10}</span>



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Let's consider a simple example.
                <li>We define the input property as a sequence of
                  integers.
                <li>The output property states that the output of the
                  SUT is the sum of the values in input sequence.
                <li><font color="green">[show #1]</font>
                  Here is code showing what this would look like
                  implemented with Clojure's test.check library.
                  Namespace imports have been elided.
                <li><font color="green">[show #2]</font>
                  First we define the SUT to be the application of sum
                  to a sequence.
                <li><font color="green">[show #3]</font>
                  The input property P is defined as a compound
                  generator which generates a vector of integers.
                <li><font color="green">[show #4]</font>
                  The output property states that the execution of
                  the SUT on P should have the exact same result
                  as apply sum to the values in P.
                <li><font color="green">[show #5]</font>
                  We define our properties using the props-all
                  function.
                <li><font color="green">[show #6]</font>
                  and we call the quick-check function to run 10
                  test iterations.
                <li><font color="green">[show #7]</font>
                <li>The final two lines are the result of the test
                  showing that all 10 iterations were run with no
                  property violations.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font style="visibility: hidden" color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (apply + x)))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 100}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>We can increase the number of iterations to 100
                  and see that the result is unchanged. Which is not
                  surprising since our test Oracle output property and
                  the SUT are currently defined identically.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 10
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result true,
 :num-tests 10}



              </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>Now let's introduce a bug in our SUT such that
                  any sequence containing 13 to 17 integers will
                  result in the value 0 being returned instead of the
                  sum.
                <li>Our properties remain unchanged.
                <li>We can see that running 10 iterations still passed
                  because the length of P is still small and no
                  sequence is long enough to trigger the bug is
                  generated.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Simple PBT Example</h3>
            <div style="position:absolute">
              <ul>
                <li>Input property: P is a sequence of integers</li>
                <li>Output property: sum of integers in P <font color="green">(almost)</font></li>
              </ul>
              <pre><code class="clojure" data-noescape>> (def SUT
    (fn [x] (if (<= 13 (count x) 17) 0 (apply + x))))

> (tc/quick-check 100
    (props/for-all
      [P (gen/vector gen/int)]
      (= (SUT P) (apply + P))))
{:result false,
 :num-tests <span class="fragment mark-current-blue" data-fragment-index=1>31</span>,
 :fail [<span class="fragment mark-current-blue" data-fragment-index=2>[1 19 12 18 -7 30 -8 15
         13 -15 8 -3 1 -21 10 19]</span>],
 :shrunk {:total-nodes-visited <span class="fragment mark-current-blue" data-fragment-index=3>262</span>,
          :smallest [<span class="fragment mark-current-blue" data-fragment-index=4>[0 0 0 0 0 0 0 0 0 0 0 0 0]</span>]}} </code></pre>
            </div>
            <aside class="notes">
              <ul>
                <li>However, running with a maximum of 100 iterations
                  triggers a test case failure on the
                  <font color="green">[show #1]</font> 31st iteration.
                <li>The initial input property which triggered the
                  failure contained <font color="green">[show #2]</font> 16 integers.
                <li>After the failure was discovered, the quick-check
                  function ran an addition
                  <font color="green">[show #3]</font> 262 test shrink iterations
                  and found that a sequence of
                  <font color="green">[show #4]</font> 13 zeros that triggers
                  the failure. This is the smallest test case that was
                  found that still triggered the failure.
              </ul>
            </aside>
          </section>
        </section>
        <section data-transition="none">
          <section>
            <h2>Input Generators</h2>
            <ul>
              <li>Test Case Composition (web pages):
                <ul>
                  <li>HTML (content)
                  <li>CSS (presentation)
                </ul>
                <!--
              <li class="fragment">Goals:
                <ul>
                  <li>Automated
                  <li>Controllable
                </ul>
                -->
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="red">10:22</font>
                  Now let's talk about the the input properties for
                  browser render testing. In this case we want to
                  generate web pages which mean generating HTML and
                  CSS. These basically represent the content and
                  presentation respectively. The third component of
                  web page is the behavior defined in JavaScript but
                  that is not in scope for this project.
                <!--
                <li><font color="green">[show #1]</font>
                  The are several goal we want for our generators:
                  <ul>
                    <li><b>Automated</b>: We want automated creation
                      of the generators based on specifications, and
                      we also want the generators to output full web
                      pages that don't require human final assembly or
                      tweaking.
                    <li><b>Controllable</b>: Because the domain of valid web
                      pages is essentially unbounded, we want the
                      tester to have the ability to choose more narrow
                      domains to focus on.
                  </ul>
                -->
              </ul>
            </aside>
          </section>
          <section>
            <h3>Grammar-Based Generators</h3>
            <ul>
              <li class="fragment">W3C Specifications &rarr; Spec Data
              <li class="fragment">Spec Data &rarr; EBNF Grammar
              <li class="fragment">Grammar EBNF &rarr; Generators
              <li class="fragment">Generators &rarr; HTML+CSS
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show #1]</font>
                  Our basic approach is to first download and
                  normalize HTML and CSS specification data.
                <li><font color="green">[show #2]</font>
                  Then we load that data and use it to generate
                  EBNF grammars that can parse web pages containing
                  HTML and CSS.
                <li><font color="green">[show #3]</font>
                  Then we parse the EBNF grammar files and output
                  generator functions for each of the rules in the
                  grammar.
                <li><font color="green">[show #4]</font>
                  Finally, the PBT test harness is able to use the
                  generators for our input properties to generate HTML
                  and CSS test cases.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul class="fragment" style="list-style: none">
              <li>VDS
            <pre><code class="css overflow"  data-noescape><'text-emphasis-position'> =
  [ over | under ] && [ right | left ]</code></pre>
              <li class="fragment">EBNF
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;</code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="red">11:25</font>
                <li>So for a concrete example of how we use
                  specification data to create generators I'm going to
                  give and example for one aspect of the CSS standard.
                <li>The bulk of the CSS3 standard is dedicated to
                  defining CSS values. CSS values are defined using
                  a bespoke grammar called Value Definition Syntax (or
                  VDS).
                <li>The grammar is similar to EBNF but with additional
                  combinators that are optimized to deal with the
                  ordering and repetition flexibility that CSS values
                  permits.
                <li><font color="green">[show #1]</font>
                  Here is an example from the specification for the VDS
                  definition of the values for the
                  <b>text-emphasis-position</b> property name.
                <li>This definition states that the value should be
                  either the word "over" or "under" and either the
                  word "right" or "left".
                <li><font color="green">[show #2]</font>
                  This is the equivalent EBNF translation of the VDS
                  grammar.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS Value Definition Syntax (VDS)</h3>
            <ul style="list-style: none">
              <li>EBNF
            <pre><code class="bash overflow"  data-noescape>prop-text-emphasis-position =
  ( ( 'over' ' ' | 'under' ' ') ' '
    ( 'right' ' ' | 'left' ' ') ' ' ) ;</code></pre>
              <li>Generators:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [100 (gen/tuple (gen/return "over") (gen/return " "))]
    [100 (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [100 (gen/tuple (gen/return "right") (gen/return " "))]
    [100 (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>The EBNF is then translated into Clojure
                  test.check generator code.
                <li>The frequency generator selects between multiple
                  other generators based on weights. In this case the
                  even weights result in 50% chance of choosing the
                  over/under and right/left pairs.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Controlling the Grammar</h3>
            <ul>
              <li>Tunable weights at grammar alternation points
              <!-- DROP if time short
              <li class="fragment">Enables:
                <ul>
                  <li>Single component testing
                  <li>Avoid known failures
                  <li>Pairwise or combinatorial testing
                  <li>Typical and atypical test cases
                </ul>
              -->
            </ul>
            <aside class="notes">
              <ul>
                <li>One of our goals of our overall approach is that
                  the system is controllable.
                <li>We accomplish this by having tunable weights
                  associated with each branch point in the grammar.
                <li>By tunning the grammar the tester can decide what
                  sort of testing to perform. Some examples include
                  single component testing, avoiding known failures,
                  pairwise testing, typical and atypical test cases.
                <!--
                <li><font color="green">[show #1]</font>
                  Grammar controlability enables a number of
                  interesting scenarios such as:
                  <ul>
                    <li><b>Single component testing</b>. For example
                      there may be a new HTML element that we want to
                      focus our testing on.
                    <li><b>Avoid known failures</b>. For example, we
                      may have found a bug hyperlink rendering that
                      occurs frequently. We can continue testing
                      without requiring a fix to the SUT by disabling
                      the part of the grammar that generates
                      hyperlinks.
                    <li><b>Pairwise or combinatorial testing</b>. Many
                      bugs are triggered by the interaction a small
                      number of components that make up the SUT. So
                      pairwise and combinatorial testing can be an
                      efficient way to locate bugs in the SUT.
                    <li><b>Typical and atypical test cases</b>.
                      Sometimes we are interested in testing our SUT
                      on typical data. For example we may want to gain
                      confidence that our browser will render the top
                      100 web sites correctly. Other times we may want
                      to focus on uncommon elements. Perhaps we just
                      introduced some new elements to the SUT that are
                      not widely used yet.
                  </ul>
                -->
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Revisiting the Grammar</h3>
            <ul style="list-style: none">
              <li><font color="yellow">text-emphasis-position</font> generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [100                                                          &nbsp;
      (gen/tuple (gen/return "over") (gen/return " "))]
    [100
      (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [100
      (gen/tuple (gen/return "right" (gen/return " ")))]
    [100
      (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is the grammar generator I showed earlier.
                <li>But this isn't complete yet because it is omitting
                  the extra parts that allow the grammar to be
                  controlled or tuned.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Revisiting the Grammar</h3>
            <ul style="list-style: none">
              <li><font color="yellow">text-emphasis-position</font> generator:
            <pre><code class="clojure overflow"  data-noescape>(gen/tuple
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 0] 100)
      (gen/tuple (gen/return "over") (gen/return " "))]
    [(get weights [:prop-text-emphasis-position :cat 1 :alt 1] 100)
      (gen/tuple (gen/return "under") (gen/return " "))]])
  (gen/return " ")
  (gen/frequency [
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 0] 100)
      (gen/tuple (gen/return "right") (gen/return " "))]
    [(get weights [:prop-text-emphasis-position :cat 3 :alt 1] 100)
      (gen/tuple (gen/return "left") (gen/return " "))]])
  (gen/return " "))
            </code></pre>
            </ul>
            <aside class="notes">
              <ul>
                <li>Here is what the full emitted grammar looks like
                  with the weight lookups included.
                <li>The weights variable in the example is a lookup
                  table built from the default weights overlayed with
                  values loaded from a weight file.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Weights File</h3>
            <ul style="list-style: none">
              <li>weights.edn:
            <pre><code class="clojure overflow"  data-noescape>{
...
 [:prop-text-emphasis-position :cat 1 :alt 0] 100,
 [:prop-text-emphasis-position :cat 1 :alt 1]  50,
 [:prop-text-emphasis-position :cat 3 :alt 0] 100,
 [:prop-text-emphasis-position :cat 3 :alt 1]  50,
...
}</code></pre>
            <aside class="notes">
              <ul>
                <li>This weight file snippit corresponds to the
                  text-emphasis-position property I just showed.
                <li>The weights have been modified to make the "over"
                  and "right" words twice as common as "under" and
                  "left".
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Demo Time</h2>
            <p><font color="yellow">instacheck</font> - <font color="green">instaparse meets test.check</font></p>
            <aside class="notes">
              <font color="red">15:15</font>
              <ul>
                <li>So now I'm going to demonstrate property-based
                  testing and grammar-based test case generation. This
                  part of the project is generically useful so I split
                  it off into a standalone project called instacheck.
                  Let's try it out.
              </ul>
              <pre style="font-size: 0.5em">
vi test/numbers.ebnf
lein run samples test/numbers.ebnf tmp/samp%.nums
grep '.' tmp/samp%.nums | less
lein run samples test/numbers.ebnf tmp/samp%.nums --weights-output tmp/number-weights.edn
vi tmp/number-weights.edn
lein run samples test/numbers.ebnf tmp/samp%.nums --weights tmp/number-weights.edn
grep '.' tmp/samp%.nums</pre>
              <hr>
              <pre style="font-size: 0.5em">
lein run clj test/numbers.ebnf foo.bar &gt; tmp/numbers.clj
vi tmp/numbers.clj</pre>
              <ul>
                <li>Show generating samples
                <li>Show generating clj code
              </ul>
          </section>
          <section>
            <h2>Demo Time</h2>
            <p><font color="green">Instacheck</font></p>
            <aside class="notes">
              <pre style="font-size: 0.5em">
vi test/math.ebnf
vi test/mathtest.sh
lein run check test/math.ebnf tmp/samp%.exp -- ./test/mathtest.sh %
grep '.' tmp/samp*.exp
lein run check test/math.ebnf tmp/samp%.exp --iterations 50 --seed 3 -- ./test/mathtest.sh %
./test/mathtest-verbose.sh ...
./test/mathtest-verbose.sh tmp/sampfinal.exp</pre>
              <hr>
              <pre style="font-size: 0.5em">
vi ../tend/data/html5.ebnf
lein run samples - -samples 20 ../tend/data/html5.ebnf tmp/samp%.html
vi tmp/samp19.html</pre>
              <ul>
                <li>check mathtest
							  	<ul>
                    <li>math.ebnf: generate simple mathematical
                      expressions
                    <li>mathtest.sh: SUT in python. Test Oracle in
                      Ruby checks the answer from SUT
                    <li>lein run check: run until fail.
                    <li>Use verobse on first: not especially clear
                      what happened
                    <li>Use verbose on final: clearer that we've
                      discovered a math precision discrepancy.
                  </ul>
                <li>samples for html.ebnf
							  	<ul>
                    <li>Emphasize: Grammar for HTML5 and CSS
                      automatically generated from specification data.
                    <li>Run: grammar with almost 500 rules so it takes
                      a few seconds to load. Much more efficient to
                      use pre-generated Clojure generator code for
                      a grammar this large.
                    <li>samp19.html:
                  </ul>
              </ul>
          </section>
          <section>
            <p>"Dad protecting the web."</p>
            <span><img src="imgs/5yr2.jpg" width=40%></img></span>
            <aside class="notes">
              <ul>
                <li>Here is another piece of art from my 5 year-old
                  son.
              </ul>
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Test Oracle</h2>
            <!--
            <ul>
              <li class="fragment">Goals
                <ul>
                  <li>Automated
                  <li>Controllable
                </ul>
            </ul>
            -->
            <aside class="notes">
              <ul>
                <li><font color="red">19:30</font>
                  We have a way to generate web page test cases
                  that is <b>automated</b> and <b>controllable</b>,
                  but how do we determine whether our browser correctly
                  renders these test cases in an automated and
                  controllable way.
                <!--
                <li>It turns out that our goals for determining
                  correctness are the same as for generating the inputs
                  <li>Goals: <font color="green">[show #1]</font>
                  <ul>
                    <li><b>Automated</b>: a human shouldn't have to
                      determine whether a browser has rendered a web
                      page correctly. Which has means we also need to
                      minimize false positives and false negatives.
                    <li><b>Controllable</b>: To explain why this is
                      important I'll have to descirbe how the test
                      Oracle works.
                -->
              </ul>
            </aside>
          </section>
          <section>
            <h2>Consensus Oracle</h2>
            <ul>
              <li>Multiple implementations
              <li class="fragment">Browsers:
                <ul>
                  <li class="fragment">Chrome, Firefox
                  <li class="fragment">Edge, Internet Explorer
                  <li class="fragment">Opera, Vivaldi
                  <li class="fragment">Brave, UC Browser
                  <li class="fragment">Chromium, Servo, Pale Moon, Dolphin, Tor Browser, Maxthon, Baidu Browser, etc, etc
                </ul>
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="green">[show #1]</font>
                  The key insight here is that a number of cases in
                  the real-world where SUTs will have multiple
                  implementations.
                <li>This is particularly true in the web browser space
                  where there is a surplus of implementations.
                  <font color="green">[show #2-]</font>
              </ul>
            </aside>
          </section>
          <section>
            <h3>Consensus Example</h3>
            <pre><code class="html"  data-noescape>&lt;html&gt;
  &lt;body style="background: #1289af; font: 25px/1 Ahem"&gt;
    &lt;marquee bgcolor="navy"&gt;
      &lt;q <font color="yellow">...ELIDED...</font> &gt; pX &lt;/q&gt;
    &lt;/marquee&gt;
    p
    &lt;mark <font color="yellow">...ELIDED...</font>&gt; &lt;/mark&gt;
    &lt;strong style="offset-anchor: right;
                   box-align: stretch;
                   padding-right: -1.75vw" <font color="yellow">...ELIDED...</font>&gt;
      &lt;mark <font color="yellow">...ELIDED...</font>&gt; Xp XX &lt;/mark&gt;
      &amp;#x00c9;
    &lt;/strong&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Here is a example web page that was generated
                  using HTML and CSS generators. Some less important
                  parts have been elided.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Consensus Example</h3>
            <table class="browser-table">
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Firefox&nbsp;&nbsp;</span>
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Chrome</span>
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <div style="visibility: hidden">FFFFFFF</div>
                  <span>Servo&nbsp;&nbsp;&nbsp;&nbsp;</span>
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
            </table>
            <aside class="notes">
              <ul>
                <li>And here are the results of rendering that page in
                  three different browsers.
                <li>It is pretty clear just from visual inspection
                  that Servo has significantly different rendering
                  from the other two however, it's not as obvious
                  whether Firefox and Chrome are different.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>Consensus Example</h3>
            <table class="browser-table">
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Firefox</span>
                  <img src="imgs/results1_7_firefox.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_firefox_servo.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Servo</span>
                  <img src="imgs/results1_7_servo.png"
                       style="margin: 5px"></img>
                </td>
              </tr>
              <tr>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_firefox_chrome.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top">
                  <span>Chrome</span>
                  <img src="imgs/results1_7_chrome.png"
                       style="margin: 5px"></img>
                </td>
                <td style="padding: 0px; text-align: center; vertical-align: top"
                    class="fragment" data-fragment-index=1>
                  <img src="imgs/results1_7_diff_chrome_servo.png"
                       style="margin: 5px"></img>
                  <div style="visibility: hidden">FFFFFFF</div>
                </td>
              </tr>
            </table>
            <aside class="notes">
              <ul>
                <li>Let's re-arrange them
                <li>And now let's show the result of subtracting the
                  color channel values for each pair of browsers.
                  <font color="green">[show #1]</font>
                  Black areas in the difference images mean that color
                  at that pixel in both images was identical.
                <li>Now it's easy to see the difference between Servo
                  and the other two browsers.
                <li>We can also see that Firefox and Chrome are very
                  similar although there are in fact some subtle
                  spacing differences between the HTML elements.
                <li>This raises the question of how do we determine if
                  there is in fact consensus or not?
              </ul>
            </aside>
          </section>
          <section>
            <h3>Consensus?</h3>
            <ul style="list-style: none">
              <li class="fragment">Squared Sum of Differences (SSD) with a threshold.
            </ul>
            <aside class="notes">
              <ul>
                <li>There are numerous methods of comparing two images
                  described in the literature. There is even some
                  consideration of using machine learning approaches
                  for comparing two browser renderings to determine if
                  they are similar enough to be indistinguishable to
                  the human eye.
                <li>The fact is that the comparison method is
                  something that testers in practice will want to have
                  control over. This is an aspect of controllability
                  of the consensus algorith mentioned above.
                <li><font color="green">[show #1]</font>
                  We found that a simple Squared Sum of Differences
                  compared to configurable threshold value was
                  sufficient to validate our overall approach.
              </ul>
            </aside>
          </section>
          <section>
            <h3>Consensus Yet?</h3>
            <ul style="list-style: none">
              <li class="fragment">One is at fault
              <li class="fragment">All members at fault
              <li class="fragment">No clear fault
            </ul>
            <aside class="notes">
              <ul>
                <li>We now have an answer for whether each pair of
                  browsers are different from each other. With three
                  browsers, there are three pairs of difference
                  values. What if they disagree?
                <li><font color="green">[show #1]</font>
                  It's fairly easy to tell when one browser is at
                  fault because it will be different from all other
                  browsers and the other browsers will have
                  self-similar renders.
                <li><font color="green">[show #2]</font>
                  There is also a case where all browsers may be
                  different from every other browser. We found that
                  this is often indicative of a gap or ambiguity of
                  the standard for one of the components on the page.
                <li><font color="green">[show #3]</font>
                  And there is also a case where there is no clear
                  browser at fault. Consider an example where A and
                  B are below threshold, and B and C are also below
                  the threshold, but A and C are above the threshold
                  and classified as different. In other words, browser
                  B split the difference between the other two.
                <li>This is another area where the tester will want
                  controllability and will likely select different
                  consensus algorithms depending on the goal.
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <h2>Test System Architecture</h2>
          <img src="imgs/test_arch_sideways.svg" width=100%></img>
          <aside class="notes">
            <ul>
              <li><font color="red">25:00</font>
                Left: shows retrieving and processing the HTML5 and
                CSS3 standards data from MDN.
              <li>Top right: is the browsers configured in our
                consensus pool.
              <li>Right: we generate test cases and store them in our
                data store which is served up by our embedded web
                server. The test driver then uses the webdriver
                protocol to connect to the browsers to make them load
                each test case and then grab a screenshot. The
                screenshots and delta data are also captured in the
                data store.
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h2>Demo Time</h2>
            <p><font color="yellow">tend</font> - <font color="green">browser render testing</font></p>
            <aside class="notes">
              <font color="red">26:54</font>
              <pre style="font-size: 0.5em">
vi config.yaml
lein trampoline run config.yaml</pre>
              <ul>
              <li>Show config.yaml
              <li>Run:
                <ul>
                  <li>Establishing connections to headless browsers
                    via webdriver protocol.
                  <li>Start web server to serve test cases to browser
                    and to serve the summary report page.
                  <li>
                </ul>
              <li>Report page:
                <ul>
                  <li>Dynamically updated via websocket connection with server.
                  <li>Explain the columns
                  <li>Load and show firefox, Chrome and delta
                <ul>
              </ul>
          </section>
          <section>
            <p>"The web has a spider named Oracle, and Daddy is
            protecting and fixing it. That’s his house he lives
            in."</p>
            <span><img src="imgs/6yr2.jpg" width=35%></img></span>
            <aside class="notes">
              <ul>
                <li>I couldn't resist one more. Here is one final
                  piece of art by my 6 year old daughter.
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <h3>Review</h3>
          <ul style="list-style: none">
            <li>The Challenges
              <ul style="list-style: none">
                <li>Test Cases
                <li>Test Oracle
              </ul>
            <li>A Solution
              <ul style="list-style: none">
                <li>Property-Based Testing
                  <ul style="list-style: none">
                    <li>Test Shrinking
                  </ul>
                <li>Grammar-Based Input Generators (<font color="yellow">instacheck</font>)
                <li>Consensus-Based Test Oracle (<font color="yellow">rend</font>)
              </ul>
          </ul>
          <aside class="notes">
            <ul>
              <li><font color="red">31:30</font>
                Okay, let's briefly recap.
              <li>The challenges of browser render testing that I've
                addresses basically fall into two categories: test
                case generation and the test oracle. However, in both
                cases can really be summed up as end-to-end
                automation.
              <li>There are three components to the solution:
                <ul>
                  <li>First, property-based testing is framework for
                    automated generative testing in which the test
                    system searches for an input property that
                    violates the output property. A critically
                    important feature of most PBT systems is test
                    shrinking which reduces the result so it is useful
                    for debug purposes.
                  <li>Second, we create controllable grammar-based input
                    generators based on web specificatiions. These
                    generators can create random web pages as test
                    cases. Controllability is important for narrowing
                    the unbounded input space to what the tester wants
                    to focus on.
                  <li>Third, we use multiple browser implementations
                    together to automate the process of determining
                    when browser rendering is incorrect or at least
                    in disagreement. Controlability is important here
                    too for determining what the meaning of
                    disagrement is for the tester.
                </ul>
            </ul>
          </aside>
        </section>
        <section>
          <h3>Links & Contact</h3>
          <ul style="list-style: none">
            <li><a href="http://kanaka.github.io/strangeloop2018">kanaka.github.io/strangeloop2018</a>
            <li><a href="https://github.com/kanaka/instacheck">github.com/kanaka/instacheck</a>
            <li><a href="https://github.com/kanaka/tend">github.com/kanaka/tend</a>
            <li><a href="https://twitter.com/bus_kanaka">@bus_kanaka</a>
            <li>joel.martin@viasat.com
            <li><font color="yellow">We're hiring:</font> <a href="https://viasat.com/careers">viasat.com/careers</a>
          </ul>
          <br>
          <br>
          <div class="fragment">
            <h3>Questions?</h3>
            <p><font color="cyan">https://sli.do</font> <font color="yellow">(Event #SL18)</font></p>
          </div>
          <aside class="notes">
            <ul>
              <li>Okay, here is some information for further
                information.
              <li>The first link is this presentation material.
              <li>Also, I want to mention that ViaSat is hiring.
                ViaSat is a great company working on really
                interesting stuff. Also, we have satellites in space.
                So check out the careers page.
              <li><font color="green">[show #1]</font>
              <li>Okay, I think we have a few minutes for questions.
              <li><font color="red">34:00</font>
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h2>Extra Material</h2>
          </section>
          <section>
            <h3>Beyond Browsers</h3>
            <ul>
              <li class="fragment">Implementation of standards
              <li class="fragment">Regression/fix testing
              <li class="fragment">Feature support matrix
            </ul>
            <aside class="notes">
              <ul>
                <li>There are other instances beyond browsers where
                  there are this approach would work. PDF rendering.
                  POSIX utility implementations.
                  <font color="green">[show #1]</font> Basically any
                  area where there is a software will often have
                  multiple implementations.
                <li><font color="green">[show #2]</font>
                  However, not just for cases where there are multiple
                  implementation from different vendors/creators. This
                  approach could also be used for testing of multiple
                  versions of the same SUT.  With a bit of integration
                  with source control and automated testing systems
                  this could be used to identify regressions and
                  if/when they are fixed.
                <li><font color="green">[show #3]</font>
                  It could be used to create a feature matrix
                  showing when a product began supporting a feature by
                  comparing the most recent version against older
                  versions of the product.
              </ul>
            </aside>
          </section>
          <section>
            <h3>HTML 5</h3>
            <ul>
              <li>W3C Standard
              <li>130 Elements (tags)
              <li>110 Attributes
            </ul>
            <aside class="notes">
              <ul>
                <li><font color="red">14:30</font>
                <li>Let's talk briefly about HTML. HTML is a World
                  Wide Web Consortium standard. HTML 5 is the current
                  major version of the standard.
                <li>HTML is composed of two major parts: elements and
                  attributes.
                <li>The standard defines approximate 130 HTML elements
                  and 110 attributes.
              </ul>
            </aside>
          </section>
          <section>
            <h3>HTML Example</h3>
            <pre><code class="html" data-noescape>&lt;<span class="fragment mark-current-blue" data-fragment-index=2>html</span>&gt;
  &lt;<span class="fragment mark-current-blue" data-fragment-index=2>body</span>&gt;
    page document body
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt; div content &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>span</span> <span class="fragment mark-current-blue" data-fragment-index=3>class="myclass1"</span>&gt; span content &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>span</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>div</span> <span class="fragment mark-current-blue" data-fragment-index=3>id="mydiv1"</span>&gt; div content &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>b</span> <span class="fragment mark-current-blue" data-fragment-index=3>style="text-color: red"</span>&gt; bold red text &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>b</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
      &lt;<span class="fragment mark-current-blue" data-fragment-index=2>b</span>&gt; bold text within a div &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>b</span>&gt;
      &lt;<span class="fragment mark-current-blue" data-fragment-index=2>span</span>&gt; span content within a div &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>span</span>&gt;
    &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>div</span>&gt;
    &lt;<span class="fragment mark-current-blue" data-fragment-index=2>a</span> <span class="fragment mark-current-blue" data-fragment-index=3>href="http://w3c.org"</span>&gt; text of link to W3C &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>a</span>&gt;
  &lt;/<span class="fragment mark-current-blue" data-fragment-index=2>body</span>&gt;
&lt;/<span class="fragment mark-current-blue" data-fragment-index=2>html</span>&gt;</code></pre>
            <aside class="notes">
              <ul>
                <li>Here is an example web page HTML
                <li><font color="green">[show #1]</font>
                  Elements are delineated by tags.
                <li>Note that the grammar for HTML elements is
                  recursive and permits elements to be contained
                  within other elements.
                <li><font color="green">[show #2]</font>
                  Attributes are key/values settings attached to
                  elements. Some attributes like class and id are
                  global while other like href are specific to certain
                  types of elements.
              </ul>
            </aside>
          </section>
          <section>
            <h3>CSS 3</h3>
            <ul>
              <li>W3C Standard
              <li>50 sub-specifications (modules)
              <li>360 CSS properties
            </ul>
            <aside class="notes">
              <ul>
                <li>Cascading Stylesheet (or CSS) is also a World Web
                  Consortium standard.
                <li>CSS 3 is the major version of the standard.
                <li>The CSS standard is a fair bit more complicated
                  than the HTML one in terms of its grammar.
                <li>There are actually 50 different sub-specifications
                  referred to as CSS3 modules which are in various
                  stages of standardization.
                <li>There are more than 360 CSS property names across
                  all the CSS3 modules.
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Stylesheet:
            </ul>

            <pre><code class="css"  data-noescape><span class="fragment mark-current-blue" data-fragment-index=1>.classname #idname tagname</span> {
  <span class="fragment mark-current-blue" data-fragment-index=2><span class="fragment mark-current-blue" data-fragment-index=3>background</span>: <span class="fragment mark-current-blue" data-fragment-index=4>rgba(0, 0, 0, 0.5);</span></span>
  <span class="fragment mark-current-blue" data-fragment-index=2><span class="fragment mark-current-blue" data-fragment-index=3>border</span>: <span class="fragment mark-current-blue" data-fragment-index=4>1px solid #fff;</span></span>
  <span class="fragment mark-current-blue" data-fragment-index=2><span class="fragment mark-current-blue" data-fragment-index=3>transform</span>: <span class="fragment mark-current-blue" data-fragment-index=4>translate3d(0px, 0px, -45px) rotateX(90deg);</span></span>
}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Here is an example of a CSS stylesheet.
                <li>There are four main components
                <li><font color="green">[show #1]</font>
                  Selectors, which identify which HTML elements the
                  following block will apply to.
                <li><font color="green">[show #2]</font>
                  A block of declarations.
                <li>Each declaration consists of ...
                <li><font color="green">[show #3]</font>
                  Property names and ...
                <li><font color="green">[show #4]</font>
                  Value data
              </ul>
            </aside>
          </section>
          <section data-transition="none">
            <h3>CSS 3 Example</h3>
            <ul style="list-style: none">
              <li>Inline:
            </ul>
            <pre><code class="html"  data-noescape>&lt;div style="background: rgba(0, 0, 0, 0.5);
            border: 1px solid #fff;
            transform: translate3d(0px, 0px, -45px)
                       rotateX(90deg);"&gt;
  div content
&lt;/div&gt;
            </code></pre>
            <aside class="notes">
              <ul>
                <li>These are the same definitions from the previous
                  example but embedded inline into the HTML.
                <li>The selectors are omitted because these
                  declarations only apply to the HTML elements that
                  they embedded within.
              </ul>
            </aside>
          </section>
          <section>
            <h2>Results</h2>
            <table>
              <tr class="fragment" data-fragment-index=1>
                <th width=35%>&nbsp;</th>
                <th>Median</th>
                <th>Maximum</th>
              <tr class="fragment" data-fragment-index=1>
                <td>First fail</td>
                <td>8 iterations</td>
                <td>15 iterations</td>
              <tr class="fragment" data-fragment-index=2>
                <td>Fail size</td>
                <td>3,025 bytes</td>
                <td>109,983 bytes</td>
              <tr class="fragment" data-fragment-index=3>
                <td>Shrunk</td>
                <td>154 bytes</td>
                <td>245 bytes</td>
            </table>
            <aside class="notes">
              <ul>
                <li>
                  We created an implementation of the approach
                  described and ran the system with a consensus pool
                  that included the Firefox, Chrome and Servo
                  browsers.
                <li>Across 130 test runs, every run identified
                  a failure case before hitting the maximum number of
                  iterations we had specified.
                <li><font color="green">[show #1]</font> In
                  fact, the maximum number of steps until a failing
                  case was found was 15. The median number of
                  iterations to find a failure case was 8.
                <li>We were actually surprised by how quickly the
                  system was able to generate test cases that
                  triggered browser differences. But the reason is
                  something I mentioned earlier: due to the nature of
                  the generators, the size of each test case increases
                  rapidly and large numbers of features are tested per
                  test case.
                <li><font color="green">[show #2]</font> The
                  median size of the first failing test case was
                  3 kilobytes and the maximum was 110 kilobytes.
                <li><font color="green">[show #3]</font> The
                  median size of the test case after shrinking was
                  154 bytes and the maximum was 245 bytes. The median
                  number of steps needed to shrink a test case was
                  113 iterations. You can see how powerful the
                  shrinking process is and the utility for the tester.
                <li>Most of the failing test cases were due to the
                  generators creating web pages that used elements of
                  HTML and CSS that are either considerecd obsolete
                  (often because they don't have common behavior
                  across browsers) or that are relatively new elements
                  that are in the process of standardization
              </ul>
            </aside>
          </section>
          <section>
            <img src="imgs/results1.png" width=80%></img>
            <aside class="notes">
            </aside>
          </section>
          <section>
            <img src="imgs/results1_expanded.png" width=80%></img>
          </section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>

<!-- vim: ts=2:sw=2:set expandtab -->
